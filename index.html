<html>
<head>
<script src = "j.js"></script>
<script src = "json.js"></script>
<script>
function is_symbol(str) {
    return "( )'\"\u000a\r\n".indexOf(str) == -1;
}
function is_space(chr) {
    return "\n\r\t\u000a ".indexOf(chr) != -1
}
function o(level, label, obj){
    return;
    $('body').append($("<div style = 'margin-left: "
        + (10 * level)+ "px; border: 1px solid navy;'>"
        +label+": " + $.toJSON(obj) + "</div>"))
}
function line(level, color) {
    return;
    $('body').append("<div style = 'border-bottom: 4px solid "+color+"; margin-top: 5px; margin-bottom: 8px; margin-left: "+(10 * level)+";'>")
}
$(document).ready(function(){
    var code = parse($('drewby').html());
    $('body').append($.toJSON(code))
    run(code)
})
function print_out(state, exp, val, chr, level) {
    o(level, "symbol", state); o(level, "exp", exp)
    o(level, "var", val); o(level, "chr", chr)
    line(level,'red')
}
function print(x) {
    if (typeof x == "object") { x = $.toJSON(x)} 
    $('body').append($("<div style = 'border: 1px solid navy;'>" + x + "</div>"))
}
function printc(x,c,w) {
    w = w || 1;
    if (typeof x == "object") { x = $.toJSON(x)} 
    $('body').append($("<div style = 'border: "+w+"px solid "+c+";'>" + x + "</div>"))
}

function head(arr){ //car
    return arr[0];
}
function tail(arr) { //cdr
    return arr.slice(1)
}

function run(code) {
    function get_id_maker(){
        var x = 0;
        function inc(){
            return x++;
        }
        return inc;
    }
    var get_id = get_id_maker(); 
    //these are the built-in functions
    
    //should I have an id for each object/value??
    var heap  = {
        '0' : "test",
        '1' : 13
    }    
    var global = {
        'eval' : function(exp,scope){
            if (typeof exp == "object") {
                var func = exp[0]; //func name is first one
                var args = exp.slice(1)
                var func = this.eval(func) //|| this.empty;
                // to be continued
                //todo: lazy evaluation, acually calling of the function
            } else if (typeof exp == "string") {
                return this.lookup(exp, scope)
            }
        },
        'lookup' : function(symbols,scope) {
            if (typeof symbols == "object") {  //peeple.bob.arm
                if (symbols.length == 1){
                    return this.lookup(symbols[0], scope)
                }
                return this.lookup(tail(symbols), this.lookup(head(symbols), scope)) //que?
            } else { //just one
                if (symbols in scope){
                    return scope[symbols].value; //this will change. things are stored like {value: "yo", 'type' : "string"} ??
                } else {
                    if ('parent' in scope) {
                        return this.lookup(symbols, scope.parent)
                    } else {
                        return 0;//throw error
                    }
                }
            }
        },
        'set' : function(args, scope){
            var id = get_id();
            scope[args[0]] = id;
            heap[id] = this.eval(args[1], scope)
        }
    }
    
    for (var i = 0; i < code.length; i++) {
        var exp = code[i]
        global.eval(exp, global) //explicit scope
    }
    //(a-str call deff set if lookup a o)
}

function parse(str){
    var arr = str.split('')
    var i = 0
    var original_string = str
    return parse2({state: "symbol", exp: [], val: [], chr: arr[i], level: 0})
    //here we have a function inside a function.
    //this is so the inner function gets i as part of the scope
    //do implement this in other languages
    //you could pass i as a pointer, (or wrap it in an array like in python or javascript)
    //or you could use a class      
    function parse2(scope) {
        print_out(scope.state, scope.exp, scope.val, scope.chr, scope.level)
        if (scope.state == "symbol") {
            if (is_symbol(scope.chr)) {
                scope.val.push(scope.chr)
            } else if (is_space(scope.chr)) {  //shaping youth
                if (scope.val.length > 0) {
                    scope.exp.push(scope.val.join(''))
                    scope.val = []
                }
            } else if (scope.chr == "(") {
                i++
                scope.exp.push(parse2({state:"symbol", exp:[], val:[], chr:arr[i], level: scope.level + 1}))
            } else if (scope.chr == ")") {
                if (scope.val.length > 0) {
                    scope.val = scope.val.join('')
                    scope.exp.push(scope.val)
                    scope.val = [];
                }
                print_out(scope.state, scope.exp, scope.val, scope.chr, scope.level)
                return scope.exp
            } else if (scope.chr == '"' || scope.chr == "'") {
                if (scope.val.length == 0) {
                    scope.state = "quote"
                    scope.quote_type = scope.chr
                } else { //we have a special quotation thing going on 
                    var search = scope.val.join('');
                    scope.val = [];
                    
                    var end = str.indexOf('"' + search, i+1);
                    if (end == -1) {
                        return "error! you didn't properly close your special quote";
                    }
                    var the_string = str.substring(i + 1,end)
                    i = end + (('"' + search).length  - 1)
                    scope.exp.push(['str', the_string])
                } 
            }
        } else if (scope.state == "quote") {
            if (scope.chr == scope.quote_type) {
                scope.exp.push(["str",scope.val.join('')])
                scope.val = []
                scope.state = "symbol"
            } else if (scope.chr == "\\"){
                scope.state = "quote-escape"
            } else {
                scope.val.push(scope.chr)
            }
        } else if (scope.state == "quote-escape") {
            if (scope.chr == scope.quote_type) {
                scope.val.push(scope.chr);
            } else if (scope.chr == '\\') {
                scope.val.push("\\")
            } else {
                scope.val.push("\\")
                scope.val.push(scope.chr)
            }
            scope.state = "quote"
        }
        i++
        if (i >= arr.length) {
             if (scope.val.length > 0) {
                scope.val = scope.val.join('')
                scope.exp.push(scope.val)
                scope.val = [];
            }
            print_out(scope.state, scope.exp, scope.val, scope.chr, scope.level)
            line(scope.level, 'green')
            return scope.exp
        }
        scope.chr = arr[i]
        return parse2(scope) //this could be implemented iteratively easily.
    }
}
</script>
</head>
<body>
    <drewby>
    (t aa"abc some things are
    n"t like they ""seem""aa)
    
    (print (concat "a" "b") for you (to (do to) (me)))
    
    </drewby>
    
    <other style = "display: none;">
     ((get this) you (are great 'yea'))
    (print "hello world")
    (print (concat "yo" ":dude"))
    (set a "ten")
    (comment too much recursion (print (get-scope)))
    
    (def (go-here a b) 
        (print a)
        (print "and")
        (print b) 
    )
    </other>
    
    <div style = "display: none;">
    (comment 
        (def (test a b c) 
         
            (print "shoudn't see this")
            (print2 b)
            (print2 (+ b c))
        )
        (test 1 3 6)
    )
    
    (comment
        functions
        hash
        list
        explicit scope
        dynamic
        run-time identifiers
        tail recursion/goto 
        lookups
    )
    </div>
    <pre>
    code is data.
    data and metadata.
    tail recursion optimization/goto
    everything a function.
    by val. by referecnce
    lazy evaluation vs eager.
    can implement call
    can implement lookup
    access memory
    data stuctures
    mutable/immutable
    closures,
    recursion
    </pre>
    
</body>
</html>